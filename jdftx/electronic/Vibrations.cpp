/*-------------------------------------------------------------------
Copyright 2013 Ravishankar Sundararaman

This file is part of JDFTx.

JDFTx is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

JDFTx is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with JDFTx.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------*/

#include <electronic/Vibrations.h>
#include <electronic/IonicMinimizer.h>
#include <electronic/Everything.h>
#include <electronic/operators.h>
#include <core/LatticeUtils.h>
#include <core/Units.h>

Vibrations::Vibrations() : dr(0.01), centralDiff(false), useConstraints(false),
translationSym(true), rotationSym(false), omegaMin(2e-4), T(298*Kelvin), omegaResolution(1e-4)
{
}

void Vibrations::setup(Everything* e)
{	this->e = e;
	//Perform any compatibility checks here (so that dry runs will pick these up)
	if((translationSym || rotationSym) && useConstraints)
	{	logPrintf("WARNING: Vibrations: switching off translationSym and rotationSym since useConstraints is on.");
		translationSym = false;
		rotationSym = false;
	}
}

inline void setPtest(size_t iStart, size_t iStop, const vector3<int>& S, std::vector<double*> Ptest, vector3<> split)
{	vector3<> invS; for(int k=0; k<3; k++) invS[k] = 1./S[k];
	THREAD_rLoop
	(	for(int k=0; k<3; k++)
		{	double xk = invS[k] * iv[k];
			if(xk > split[k]) xk-=1.;
			Ptest[k][i] = xk;
		}
	)
}

void Vibrations::calculate()
{
	logPrintf("------ Vibrations::calculate() -------\n");
	logPrintf("WARNING: Vibrations module is experimental. Please report bugs!\n");
	logPrintf("Compare results with and without symmetries and report discrepancies.\n");

	//Create a non-constraint which simplifies the logic below
	SpeciesInfo::Constraint nullConstraint;
	nullConstraint.moveScale = 1.;
	nullConstraint.type = SpeciesInfo::Constraint::None;
	
	//Determine number of degrees of freedom:
	struct Mode
	{	unsigned s; //!< species number
		unsigned a; //!< atom number
		vector3<> n; //!< cartesian direction
		bool isPrimary; //!< whether this mode belongs to the irredicuble wedge (false => generated by symmetrization)
		bool fromTranslation; //!< whether this mode is filled in by the translation symmetry
	};
	std::vector<Mode> modes;
	int nPrimary = 0; //number of modes with isPrimary=true
	bool foundTranslatable = false; //found an atom to fill in using translation symmetry
	const auto& species = e->iInfo.species;
	const std::vector< matrix3<int> >& sym = e->symmUnperturbed.getMatrices();
	const std::vector< std::vector< std::vector<int> > >& atomMap = e->symmUnperturbed.getAtomMap();
	for(unsigned s=0; s<species.size(); s++)
	{	const SpeciesInfo& sp = *(species[s]);
		std::vector<bool> isPrimary(sp.atpos.size(), true);  //whether atom is the first of a set related by symmetries
		for(unsigned a=0; a<sp.atpos.size(); a++)
		{	//Find allowed directions of motion for this atom (accounting for move flags and constraints)
			std::vector< vector3<> > nSet; //list of allowed cartesian directions
			const SpeciesInfo::Constraint& c = useConstraints ? sp.constraints[a] : nullConstraint;
			if(!c.moveScale) continue;
			switch(c.type)
			{	case SpeciesInfo::Constraint::None:
				{	nSet.push_back(vector3<>(1,0,0));
					nSet.push_back(vector3<>(0,1,0));
					nSet.push_back(vector3<>(0,0,1));
					break;
				}
				case SpeciesInfo::Constraint::Planar:
				{	vector3<> a = fabs(c.d[0])<fabs(c.d[1]) ? vector3<>(1,0,0) : vector3<>(0,0,1); //=> a cannot be parallel to d
					a -= c.d * (dot(c.d,a)/c.d.length_squared()); //now a is perpendicular to d
					vector3<> b = cross(c.d, a); //b is perpendicular to a and d
					nSet.push_back(a / a.length());
					nSet.push_back(b / b.length());
					break;
				}
				case SpeciesInfo::Constraint::Linear:
				{	nSet.push_back(c.d / c.d.length());
					break;
				}
			}
			//Check whether to fillin with translation symmetries:
			bool fromTranslation = false;
			if(translationSym && !foundTranslatable)
			{	bool singleton = true; //invariant under symmetries
				for(unsigned iRot=0; iRot<sym.size(); iRot++)
					if(atomMap[s][a][iRot] != int(a))
					{	singleton = false;
						break;
					}
				if(singleton)
				{	fromTranslation = true;
					foundTranslatable = true;
					isPrimary[a] = false;
				}
			}
			//Add modes for each of these directions:
			for(const vector3<>& n: nSet)
			{	Mode mode = { s, a, n, isPrimary[a], fromTranslation };
				modes.push_back(mode);
			}
			if(isPrimary[a]) nPrimary += nSet.size();
			//Unset primary flags of symmetric images:
			for(unsigned iRot=0; iRot<sym.size(); iRot++)
				isPrimary[atomMap[s][a][iRot]] = false;
		}
	}
	int nModes = modes.size();
	logPrintf("Degrees of freedom: %d total, %d symmetry-independent.\n", nModes, nPrimary);
	if(!nModes)
	{	//Exit, but produce output in the same format as if there were modes:
		logPrintf("0 imaginary modes, 0 modes within cutoff, 0 real modes.\n");
		logPrintf("\nVibrational free energy components at T = %lg K:\n", T/Kelvin);
		logPrintf("\tZPE:   %15.6lf\n", 0.);
		logPrintf("\tEvib:  %15.6lf\n", 0.);
		logPrintf("\tTSvib: %15.6lf\n", 0.);
		logPrintf("\tAvib:  %15.6lf\n", 0.);
		logPrintf("\n");
		return;
	}
	
	//Find inverse of each symmetry matrix:
	std::vector<unsigned> iRotInv(sym.size());
	for(unsigned iRot1=0; iRot1<sym.size(); iRot1++)
		for(unsigned iRot2=iRot1; iRot2<sym.size(); iRot2++)
			if(sym[iRot1]*sym[iRot2] == matrix3<int>(1,1,1))
			{	iRotInv[iRot1] = iRot2;
				iRotInv[iRot2] = iRot1;
				continue;
			}
	
	//Initialize dipole measuring vector field
	nullToZero(Ptest, e->gInfo);
	threadLaunch(setPtest, e->gInfo.nr, e->gInfo.S, Ptest.data(), getSplit());

	//Get forces in unperturbed configuration
	int nConfigurations = 1 + nPrimary * (centralDiff ? 2 : 1);
	int iConfiguration = 0;
	IonicMinimizer imin(*e);
	IonicGradient grad0;
	imin.compute(&grad0);
	vector3<> Pel0 = getPel(); //electronic dipole moment
	logPrintf("Completed %d of %d configurations.\n", ++iConfiguration, nConfigurations);
	
	//Compute force matrix:
	matrix K = zeroes(nModes, nModes);
	matrix dP = zeroes(nModes, 3); //dipole derivative
	{	diagMatrix mult(nModes, 0.); //multiplicity in entries due to symmetrization
		IonicGradient dPrev; dPrev.init(e->iInfo); //previous displacement (initially zero)
		complex *Kdata = K.data(), *dPdata = dP.data();
		for(const Mode& mode: modes) if(mode.isPrimary) //Loop over modes in irredicuble wedge
		{	//Create ionic gradient object corresponding to mode:
			IonicGradient d; d.init(e->iInfo);
			d[mode.s][mode.a] = mode.n; //all others zero
			//Compute forces at perturbed position:
			IonicGradient gradPlus, gradMinus, Kcur;
			imin.step(d-dPrev, dr); dPrev=d;
			imin.compute(&gradPlus);
			vector3<> PelPlus = getPel(), PelMinus, dPcur; //electronic dipole moment and derivative w.r.t mode
			logPrintf("Completed %d of %d configurations.\n", ++iConfiguration, nConfigurations);
	
			if(centralDiff)
			{	d *= -1;
				imin.step(d-dPrev, dr); dPrev=d;
				imin.compute(&gradMinus);
				PelMinus = getPel();
				logPrintf("Completed %d of %d configurations.\n", ++iConfiguration, nConfigurations);
				Kcur = (gradPlus - gradMinus) * (0.5/dr);
				dPcur = (PelPlus - PelMinus) * (0.5/dr);
			}
			else
			{	Kcur = (gradPlus - grad0) * (1./dr);
				dPcur = (PelPlus - Pel0) * (1./dr);
			}
			dPcur -= species[mode.s]->Z * mode.n; //ionic contribution to dipole derivative
			
			//Collect contributions to force matrix from this mode and its symmetric counterparts:
			for(unsigned iRot=0; iRot<sym.size(); iRot++)
			{	matrix3<> rot = e->gInfo.R * sym[iRot] * inv(e->gInfo.R); //cartesian rotation matrix corresponding to symmetry
				//Modes corresponding to displacement (first index of matrix):
				unsigned a1 = atomMap[mode.s][mode.a][iRot];
				vector3<> n1 = rot * mode.n;
				std::map<int,double> dModes;
				for(int i1=0; i1<nModes; i1++)
					if(modes[i1].s==mode.s && modes[i1].a==a1)
					{	double w = dot(n1, modes[i1].n); //projection weight
						if(fabs(w) < symmThreshold) continue;
						mult[i1] += w*w; //symmetry multiplicity
						//Loop over modes corresponding to force (second index of matrix):
						for(int i2=0; i2<nModes; i2++)
						{	const Mode& mode2 = modes[i2];
							unsigned a2 = atomMap[mode2.s][mode2.a][iRotInv[iRot]]; //index of atom which upon rotation rot maps onto atom mode2.a
							Kdata[K.index(i1,i2)] += w * dot(mode2.n, rot * Kcur[mode2.s][a2]);
						}
						//Dipole derivatives:
						vector3<> rot_dPcur = rot * dPcur; //rotated dipole derivative
						for(int k=0; k<3; k++)
							dPdata[dP.index(i1,k)] += w * rot_dPcur[k];
					}
			}
		}
		IonicGradient d; d.init(e->iInfo); //all zeroes
		imin.step(d-dPrev, dr); dPrev=d; //Restore original ionic positions
		
		//Invert multiplicity matrixZero out  modes to be set by translational symmetry:
		for(int i=0; i<nModes; i++)
			mult[i] = modes[i].fromTranslation ? 0. : 1./mult[i];
		
		//Correct for multiple counting:
		K = mult * K;
		dP = mult * dP;
	}
	
	//Fill in modes set by translation symmetry, if any:
	for(int i1=0; i1<nModes; i1++) if(modes[i1].fromTranslation)
	{	//Create a uniform unit displacement of all atoms which moves current atom according to mode:
		matrix x(1, nModes); complex* xData = x.data();
		for(int i2=0; i2<nModes; i2++)
			xData[x.index(0,i2)] = dot(modes[i1].n, modes[i2].n);
		//A uniform displacement of all atoms should yield no net force
		//Except three rows of K are zero; set them so that the above becomes true.
		K.set(i1,i1+1, 0,nModes, -(x * K));
		//Simiarly polarization due to uniform displacement should be zero:
		dP.set(i1,i1+1, 0,3, -(x * dP));
	}
	
	//Symmetrize force matrix:
	logPrintf("\nRelative symmetry error in force matrix = %lg\n", 0.5*nrm2(K - dagger(K))/nrm2(K));
	K = dagger_symmetrize(K);
	
	//Project out translation / rotation modes:
	matrix projector(nModes, 6); int nProjectors=0;
	complex* projData = projector.data();
	if(translationSym)
	{	for(int k=0; k<3; k++)
		{	vector3<> e(0,0,0); e[k]=1; //unit vector
			for(int i=0; i<nModes; i++)
				projData[projector.index(i,nProjectors)] = dot(modes[i].n, e);
			nProjectors++;
		}
	}
	if(rotationSym)
	{	IonicGradient r = getCMcoords();
		//Compute inertia tensor:
		matrix3<> I;
		for(unsigned s=0; s<e->iInfo.species.size(); s++)
		{	const SpeciesInfo& sp = *(e->iInfo.species[s]);
			for(const vector3<>& rAtom: r[s])
				I += sp.mass * (rAtom.length_squared()*matrix3<>(1,1,1) - outer(rAtom,rAtom));
		}
		//Get principal axis and moments:
		matrix Imat(3,3); for(int j=0; j<3; j++) for(int k=0; k<3; k++) Imat.set(j,k, I(j,k));
		matrix Ievecs; diagMatrix Ieigs; Imat.diagonalize(Ievecs, Ieigs);
		complex* IevecsData = Ievecs.data();
		for(int j=0; j<3; j++)
			if(Ieigs[j] > symmThreshold)
			{	double meanPhase, sigmaPhase, rmsImagErr;
				removePhase(3, IevecsData+Ievecs.index(0,j), meanPhase, sigmaPhase, rmsImagErr);
				vector3<> axis; for(int k=0; k<3; k++) axis[k] = IevecsData[Ievecs.index(k,j)].real();
				//Add rotational projectors for each axis with non-zero moment:
				for(int i=0; i<nModes; i++)
					projData[projector.index(i,nProjectors)] = box(modes[i].n, axis, r[modes[i].s][modes[i].a]);
				nProjectors++;
			}
	}
	if(nProjectors)
	{	projector = projector(0,nModes, 0,nProjectors); //discard empty columns
		projector = projector * invsqrt(dagger(projector)*projector); //orthonormalize
		matrix ppDag = projector * dagger(projector);
		K -= ppDag * K * ppDag;
		//dP -= ppDag * dP;
		logPrintf("Projected out %d rotation+translation modes\n", nProjectors);
	}
	
	//Initialize mass matrix:
	diagMatrix invsqrtM(nModes);
	for(int i=0; i<nModes; i++)
		invsqrtM[i] = 1./sqrt(species[modes[i].s]->mass * amu);
	
	//Construct and diagonalize frequency-squared matrix:
	matrix omegaSq = invsqrtM * K * invsqrtM;
	diagMatrix omegaSqEigs; matrix omegaSqEvecs;
	omegaSq.diagonalize(omegaSqEvecs, omegaSqEigs);
	
	//Determine number of modes of each type:
	int iZeroStart=0, iRealStart=nModes;
	double omegaMinSq = omegaMin*omegaMin;
	double omegaSqEigPrev = -DBL_MAX;
	for(int i=0; i<nModes; i++)
	{	double omegaSqEig = omegaSqEigs[i];
		if(omegaSqEigPrev<-omegaMinSq && omegaSqEig>-omegaMinSq) iZeroStart=i;
		if(omegaSqEigPrev<+omegaMinSq && omegaSqEig>+omegaMinSq) iRealStart=i;
		omegaSqEigPrev = omegaSqEig;
	}
	logPrintf("%d imaginary modes, %d modes within cutoff, %d real modes.\n", iZeroStart, iRealStart-iZeroStart, nModes-iRealStart);
	
	//Detect degeneracies:
	std::set<int> iFreqChange; //index of modes whose energy differs (more than resolution) from previous one
	for(int i=1; i<nModes; i++)
		if(fabs(sqrt(fabs(omegaSqEigs[i])) - sqrt(fabs(omegaSqEigs[i-1]))) > omegaResolution)
			iFreqChange.insert(i);
	iFreqChange.insert(0);
	iFreqChange.insert(iZeroStart);
	iFreqChange.insert(iRealStart);
	iFreqChange.insert(nModes);
	
	const double fineStructConst = 7.29735257e-3;

	//Print modes:
	matrix dEvecs = invsqrtM * omegaSqEvecs; //displacements of the eigenvectors
	matrix Pevecs = dagger(dEvecs) * dP; // dipole moments of the eigenvectors
	diagMatrix PsqEvecs = diag(Pevecs * dagger(Pevecs)); //dipole intensity of the eigenvectors
	complex* dEvecsData = dEvecs.data();
	for(int i=0; i<nModes; i++)
	{	//Classify mode:
		string modeType; int iMode=0;
		if(i<iZeroStart) { iMode=i; modeType = "Imaginary"; }
		else if(i<iRealStart) { iMode=i-iZeroStart; modeType = "Zero"; }
		else { iMode=i-iRealStart; modeType = "Real"; }
		//Header:
		logPrintf("\n%s mode %d:\n", modeType.c_str(), iMode+1);
		//Frequency:
		double omega = sqrt(fabs(omegaSqEigs[i]));
		const char* omegaSuffix = omegaSqEigs[i]<0 ? "i" : "";
		logPrintf("Frequency: %.6lf%s Eh [ %.0lf%s cm^-1 ]\n", omega, omegaSuffix, omega/invcm, omegaSuffix);
		//Degeneracy:
		auto iterStop = std::upper_bound(iFreqChange.begin(), iFreqChange.end(), i);
		auto iterStart = iterStop; iterStart--;
		int degeneracyCount = (*iterStop) - (*iterStart);
		int degeneracyIndex = i - (*iterStart);
		logPrintf("Degeneracy: %d of %d\n", degeneracyIndex+1, degeneracyCount);
		//IR intensity:
		logPrintf("IR intensity: %.4f e^2/amu [ %.1f km/mol ]\n", PsqEvecs[i]*amu,
			PsqEvecs[i] * (M_PI/3.)*pow(fineStructConst,2) / (1e3*meter/mol));
		//Displacements:
		double meanPhase, sigmaPhase, rmsImagErr;
		removePhase(3, dEvecsData+dEvecs.index(0,i), meanPhase, sigmaPhase, rmsImagErr);
		IonicGradient d; d.init(e->iInfo);
		for(int j=0; j<nModes; j++)
			d[modes[j].s][modes[j].a] += modes[j].n * dEvecsData[dEvecs.index(j,i)].real();
		logPrintf("Displacements:\n");
		for(unsigned s=0; s<d.size(); s++)
		{	const SpeciesInfo& sp = *(e->iInfo.species[s]);
			for(const vector3<>& r: d[s])
				logPrintf("disp %s %19.15lf %19.15lf %19.15lf\n", sp.name.c_str(), r[0], r[1], r[2]);
		}
	}
	
	//Global quantities:
	double ZPE = 0., Evib = 0., Avib = 0.; //zero-point energy, average energy and free energy
	for(int i=iRealStart; i<nModes; i++)
	{	double omega = sqrt(omegaSqEigs[i]);
		double expMomegaByT = exp(-omega/T);
		ZPE += 0.5*omega;
		Evib += 0.5*omega + omega * expMomegaByT / (1.-expMomegaByT);
		Avib += 0.5*omega + T * log(1.-expMomegaByT);
	}
	double TSvib = Evib - Avib;
	logPrintf("\nVibrational free energy components at T = %lg K:\n", T/Kelvin);
	logPrintf("\tZPE:   %15.6lf\n", ZPE);
	logPrintf("\tEvib:  %15.6lf\n", Evib);
	logPrintf("\tTSvib: %15.6lf\n", TSvib);
	logPrintf("\tAvib:  %15.6lf\n", Avib);
	
	logPrintf("\n");
}

vector3<> Vibrations::getSplit() const
{	//Collect lattice coordinates of all atoms in [0,1)
	std::vector<double> x[3];
	for(const auto& sp: e->iInfo.species)
		for(const vector3<>& at: sp->atpos)
			for(int k=0; k<3; k++)
				x[k].push_back(at[k] - floor(at[k]));
	//Find best periodicity split point along each lattice direction:
	vector3<> split;
	for(int k=0; k<3; k++)
	{	std::sort(x[k].begin(), x[k].end());
		//Determine interval lengths:
		std::vector<double> dx(x[k].size());
		for(unsigned i=0; i<x[k].size(); i++)
			dx[i] = x[k][i] - (i ? x[k][i-1] : x[k].back()-1.);
		//Set split point to the midpoint of longest interval:
		int iSplit = std::max_element(dx.begin(), dx.end()) - dx.begin();
		split[k] = x[k][iSplit] - 0.5*dx[iSplit];
		split[k] -= floor(split[k]); //map to [0,1)
	}
	return split;
}

IonicGradient Vibrations::getCMcoords() const
{	vector3<> split = getSplit();
	//Collect cartesian atom coordinates with wrapping consistent with the above determined split:
	IonicGradient r; r.init(e->iInfo);
	vector3<> rMsum; double Msum = 0.; //sums for determining CM
	for(unsigned s=0; s<e->iInfo.species.size(); s++)
	{	const SpeciesInfo& sp = *(e->iInfo.species[s]);
		for(unsigned a=0; a<sp.atpos.size(); a++)
		{	vector3<> xWrapped = sp.atpos[a];
			for(int k=0; k<3; k++)
			{	xWrapped[k] -= floor(xWrapped[k]); //map to [0,1)
				if(xWrapped[k] > split[k]) xWrapped[k] -= 1.; //split periodicity along determined point
			}
			r[s][a] = e->gInfo.R * xWrapped; //to cartesian coords
			rMsum += r[s][a] * sp.mass;
			Msum += sp.mass;
		}
	}
	vector3<> rCM = rMsum / Msum; //center of mass
	//Shift coordinates relative to center of mass:
	for(std::vector< vector3<> >& rSpecies: r)
		for(vector3<>& rAtom: rSpecies)
			rAtom -= rCM;
	return r;
}

vector3<> Vibrations::getPel() const
{	vector3<> Pel;
	for(int k=0; k<3; k++)
		Pel[k] = e->gInfo.dV * dot(Ptest[k], e->eVars.get_nTot());
	return e->gInfo.R * Pel; //convert to Cartesian coordinates
}
